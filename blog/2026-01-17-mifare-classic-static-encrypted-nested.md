---
date: '2026-01-17T00:00:00+0800'
title: (節錄) 揭露 MIFARE Classic 靜態加密隨機數變體
description: 號稱修復所有已知漏洞的 FM11RF08S 晶片，竟被挖出原廠硬體後門！？只要有這「萬能金鑰」，幾分鐘就能破解整張卡。最扯的是，這後門連多個大廠二十年前的老卡都有……快來看看針對這個晶片的最新攻擊手法吧！
image: https://i.imgur.com/gzHoANv.png
tags:
  - NFC
  - RFID
meta:
  - property: og:image:width
    content: 1200
  - property: og:image:height
    content: 630
---

# (節錄) 揭露 MIFARE Classic 靜態加密隨機數變體

::: warning
本文章的內容僅限學術及研究用途，本文讀者請勿進行任何違法行為，否則後果自負。
:::

::: info
本文節錄自論文 [MIFARE Classic: exposing the static encrypted nonce variant](https://eprint.iacr.org/2024/1275) v1.6，透過 [microsoft/markitdown](https://github.com/microsoft/markitdown) 轉換成 Markdown 格式，然後使用 Gemini 3 Pro 翻譯成繁體中文，若有任何錯誤或缺漏，請以原始論文為準。
:::

![](https://i.imgur.com/gzHoANv.png)

> 我這還有一些，我該一起丟進去嗎？

作者：Philippe Teuwen，撰寫本論文時任職於：Quarkslab，電子郵件：phil@teuwen.org

## 摘要

MIFARE Classic 智慧卡由 NXP 開發並授權，被廣泛使用，但多年來一直遭受眾多攻擊。儘管推出了新版本，這些卡片仍然容易受到攻擊，即使在僅針對卡片的攻擊場景中也是如此。2020 年，中國領先的未授權「MIFARE 相容」晶片製造商發布了 FM11RF08S，這是 MIFARE Classic 的新變體。這個變體具有特定的對抗措施，旨在阻止所有已知的僅針對卡片的攻擊，並正在逐步獲得全球市場份額。在本論文中，我們展示了關於 FM11RF08S 的多種攻擊和意外發現。通過實證研究，我們發現了一個硬體後門並成功破解了其金鑰。這個後門使任何知道它的實體都能在沒有事先知識的情況下，僅通過接觸卡片幾分鐘就能破解這些卡片上所有使用者定義的金鑰。此外，我們對舊卡片的調查發現了另一個硬體後門金鑰，這個金鑰在多個製造商中是通用的。

## I. 介紹

到了 2024 年，我們都知道 MIFARE Classic 的安全機制早已經嚴重破壞。[1],
[2], [3], [4], [5], [6], [7], [8], [9], [10], [11] 但由於一定的商業遺留問題和慣性，該卡仍然非常流行，因為遷移基礎設施仍然昂貴。

在本文中，我們將專注於所謂的「針對卡片的攻擊」（card-only attacks），即可以直接在卡片上執行的攻擊，目標是恢復卡片數據和金鑰，並能夠複製或模擬它。

大約在 2020 年，出現了一種新卡，它能抵禦所有已知的針對卡片的攻擊，並具有被社群稱為「靜態加密隨機數」（static encrypted nonce）的對策。

### A. 論文概述

首先，在第二節中，我們將簡要概述 NXP 半導體公司創建的專有加密演算法和認證協議，稱為 CRYPTO-1[12]。在第三節中，我們簡要回顧 MIFARE Classic 上已知的針對卡片的攻擊。靜態嵌套攻擊是其中之一，但至今從未被記錄下來。因此，我們花了一些時間來介紹它，以歸功於開發者，並因為我們從中衍生出了新的攻擊。接著，我們在第四節介紹這款惡名昭彰的卡片及其對策。我們隨即在第五節提出了一種僅在特定條件下有效的新攻擊。在第六節中，我們解釋了一些輕微的模糊測試（fuzzing）如何暴露了一個受金鑰保護的意外指令。為了方便閱讀，我們將其簡稱為「後門」。然後，我們在第七節中使用我們的第一個攻擊來破解這個後門金鑰，並探索我們的發現範圍。基於這些知識，我們在第八節設計了一種新攻擊，可以在沒有任何條件的情況下破解所有的卡片金鑰。在某些配置下，可能需要長達 3-4 小時才能複製整張卡片。在第九節中，我們展示了另一種恢復嵌套隨機數的方法。接著，我們在第十節部分逆向了一個內部隨機數生成機制。在第十一節中，我們展示了這種部分逆向如何讓我們優化第二種攻擊，使其速度提高 5-6 倍。我們在第十二節展示了如何結合上述攻擊。在第十三節中，我們解釋了如果處於供應鏈攻擊的位置，這些攻擊如何能瞬間完成。在第十四節中，我們展示了即使不知道使用者金鑰，如何執行進階驗證方法。然後，在第十五節中，我們檢視了這張卡的舊世代，並發現了一個由另一個金鑰保護的類似後門。在第十六節中，我們調整了一個現有的攻擊來破解第二個金鑰。我們在第十七節描述了這些知識如何加速對這些舊卡的已知攻擊。我們在第十八節簡要提及 USCUID/GDM 卡片，以及在第十九節和第二十節提及一些 FM11RF08(S) 的例外情況。我們在第二十一節記錄了同樣的後門如何影響其他製造商。在第二十二節中揭露了更多的後門金鑰。最後，我們在第二十三節提出了一個僅依賴後門和僅針對讀卡機攻擊的更快速方案。

### B. 修訂

自 2024 年 8 月首次發表以來，本文經歷了多次修訂；詳情請參閱附件 A.17。
我們致力於保持整體結構和核心章節的穩定，但反覆的修訂過程可能會帶來一些流暢度上的輕微中斷。對於任何此類不一致之處，我們深表歉意。

### C. 方法論

我們採用的方法比起形式化更偏向直覺，但基於幾個關鍵點。

- 努力搜尋現有資訊，在論壇、數據表……每當出現新的關鍵字時，再次搜尋並看看它指向何處；

- 測試，挑戰假設，提出新假說並透過更多測試來挑戰它們；

- 保持一份所有未解答問題或線索想法的優先順序清單。每當出現新的未知數時，除非能立即探索，否則將其加入清單。當一個主題探索完畢後，回到清單尋找下一個熱門線索；

- 不要將自己侷限於最終目標，也要探索支線任務。誰知道呢，可能會有一些驚喜發生；

- 盯著零和一，直到你看見模式……

除了純粹的觀察和結果，本文試圖說明這種方法，並展示事件如何導向下一個步驟。

不出所料，所有實驗都是使用 Proxmark3進行的，我們將我們的分析和攻擊工具貢獻給了 Proxmark3 儲存庫 [13]。由於它不斷演進，請注意本文提及的儲存庫是指在 commit 71621470bd1ac5caae64f24d4413bc1bcc3e65ef 時的狀態。

## II. CRYPTO-1 協議

### A. 極速介紹

如果您不熟悉 MIFARE Classic 的記憶體映射、磁區、尾部區塊、金鑰和存取權限，請參閱其舊數據表之一 [14]。關於 CRYPTO-1 密碼和協議的完整描述，請參閱優秀的參考文獻 [7] 和 [8]。

讀者可以在附件 A 中找到該協議更程式化的視角。

根據 ISO14443，位元實際上是最低有效位元（LSB）優先傳輸的，但在本文中，如同文獻中一樣，數字是以通常的方式寫入，即最高有效位元（MSB）優先。

由於我們只關心針對卡片的攻擊，因此只有協議的最開始幾個步驟對我們重要：

- 發送認證指令 6***+CRC：60 用於 KeyA 認證，61 用於 KeyB 認證，後面跟著一個指示目標區塊的位元組，以及符合 ISO14443-A 的 2 位元組 CRC；
- 卡片返回一個 4 位元組隨機數 𝑛𝑇 。

如果是嵌套認證，即我們已經用已知金鑰對卡片進行了認證，並且想要在已建立的加密通道內發起新的認證，這時協議除了以下變更外是相同的：

- 指令使用當前的 CRYPTO-1 金鑰流加密發送，就像成功認證後的任何其他指令一樣；

- 卡片隨機數被加密返回，但是是用新金鑰加密的！

尚未描述的是同位位元（parity bits）的處理。
在 ISO14443-A 傳輸期間，每個位元組後面跟著一個奇同位位元（所以這 9 個位元中的 1 的總數總是奇數）。但是使用 CRYPTO-1 加密的數據傳輸方式不同：同位位元是根據明文數據計算的，然後重複使用金鑰流的下一個位元（該位元將用於加密下一個位元組的最低有效位元）進行加密。

通常，Proxmark3 協議追蹤會用符號「!」來描述同位錯誤，即傳輸位元組的真實同位性與傳輸的同位位元不匹配時，如附件範例所示。

### B. CRYPTO1 固有漏洞

我們剛剛在上一節中強調了一些重點：

- 嵌套隨機數 𝑛𝑇 是用新金鑰加密的，可能會洩漏有關金鑰的資訊；

- 同位位元應用於明文數據，可能會洩漏有關明文的資訊；

- 同位位元使用重複的金鑰流位元加密，這是另一個潛在的洩漏源。

此外，我們沒有詳細說明 CRYPTO1 密碼本身，但其內部狀態可以從金鑰流重建，因此可以回滾（roll back）直至金鑰，且效率相當高。

### C. CRYPTO1 常見實作漏洞

上一節描述了卡片無法在不破壞相容性情況下修補的漏洞。

但在卡片實作中還發現了一些漏洞，有時後來的卡片世代會修補這些漏洞。

- 32 位元隨機數 𝑛𝑇 通常是使用協議中所需的現有 16 位元線性回饋移位暫存器（LFSR）作為偽隨機數生成器（PRNG）生成的。知道隨機數的一半，我們就可以重建另一半；

- 當這樣的 PRNG 在相當短的序列上連續運行時，它大約每 0.6 秒重複一次，因此可以根據先前的隨機數預測或重放隨機數，例如在嵌套認證中；

- 初始化 16 位元 LFSR 的種子可以是靜態的，在這種情況下，甚至第一個隨機數也可以被控制和重放。取決於卡片，嘗試之間可能需要完全斷電重啟；

- 如果 8 個加密同位位元看起來是正確的（機率為 1/256），有些卡片會發送 4 位元加密的 NACK 以回應錯誤的讀卡機挑戰回應。有些卡片甚至總是回覆 NACK。接收到加密 NACK 會洩漏 4 位元金鑰流；

## III. 已知針對卡片的攻擊

### A. Darkside 攻擊

文獻 [9] 中描述的攻擊利用了前面描述的兩個實作錯誤：NACK 洩漏和獲取初始隨機數重複的可能性。

它允許在沒有已知金鑰的情況下破解第一個金鑰。因為它相當慢，一旦找到第一個金鑰，最好使用嵌套認證攻擊（如下所述）來破解所有其他金鑰。

### B. 嵌套認證攻擊

文獻 [8] 中描述的攻擊需要知道第一個金鑰。
這允許觸發嵌套認證協議並接收加密隨機數。同樣，它需要卡片具有一些實作錯誤：隨機數必須是可預測的，以便可以對嵌套 𝑛𝑇 進行猜測。加密隨機數的前三個同位位元重複使用了一些用於加密隨機數本身的金鑰流位元，因此可以過濾猜測以保留相容的猜測。通過重複攻擊 2 或 3 次，可以恢復足夠的金鑰流資訊來破解金鑰。

### C. Hardnested 攻擊

為了阻止 Darkside 和嵌套攻擊，一些卡片如 MIFARE Classic EV1 生成真正隨機的 32 位元 𝑛𝑇 ，因此不基於 16 位元 LFSR 輸出。當然，NACK 洩漏錯誤也得到了修復。

一種完全基於同位位元洩漏（這是協議的固有漏洞）的攻擊 [11] 於 2015 年發表。Hardnested 攻擊是針對強化卡片的嵌套攻擊，因此它需要第一個已知金鑰。它適用於隨機隨機數，需要大約 1600-2200 個隨機數。

### D. 靜態嵌套攻擊

有些卡片似乎具有靜態初始隨機數、靜態嵌套隨機數，且沒有 NACK 洩漏錯誤。即便如此，這些隨機數之間的距離被發現是恆定的，因此可以預測嵌套隨機數。

第一個實作是在 2020 年由 Iceman 本人 [15] 在 Proxmark3 儲存庫中提出的，基於 @xtigmh¹ 和 @uzlonewolf¹ 的解決方案。

問題在於要應用嵌套攻擊，我們需要多個隨機數，否則攻擊真的很慢：必須對卡片測試數萬個候選者，對於每個隨機數猜測）。

DXL 在 2022 年發現的技巧 [16] 是進行第二次嘗試，但這次使用以下順序：

- 使用已知金鑰進行認證；
- 然後在同一個磁區上使用相同的已知金鑰進行嵌套認證（這將成功）；
- 最後是對目標磁區的嵌套認證嘗試。

這給出了第二個不同的嵌套隨機數，並且可以離線計算金鑰。Proxmark 儲存庫 [13] 中也提供了一個 staticnested 獨立工具，基於兩個明文嵌套 𝑛𝑇 和相應的金鑰流來恢復金鑰。

## IV. 介紹 FM11RF08S

### A. 靜態加密隨機數卡片

我們已經劇透了我們感興趣的晶片型號，但事情並沒有那麼直接。

在 2020 年，我們拿到了一些卡片樣本，這些卡片具有某些特性，使得所有現有的針對卡片的攻擊都失敗了。當時，我們並沒有認真看待它們。可能只是需要對現有攻擊進行一些調整，但這不是優先事項。

大約在 2022 年，駭客社群開始認真研究它，該對策被理解並稱為「靜態加密隨機數」（static encrypted nonce）。隨著這些卡片變得越來越普遍，它逐漸成為 RFID 駭客 Discord [17] 上經常出現的話題（迄今已超過 350 次提及）。

其對策如下：
- 無 NACK 漏洞，因此無法進行 Darkside 攻擊；
- 加密嵌套 {𝑛𝑇} 是靜態的，與第一個 𝑛𝑇 無關。靜態嵌套攻擊需要能夠預測 𝑛𝑇 ，因此這裡不適用。Hardnested 攻擊需要獲取許多隨機 {𝑛𝑇}，所以也行不通。

Proxmark3 用戶端甚至整合了一個檢測功能，如清單 1 所示。

```
[usb] pm3 --> hf mf info
...
[=] --- Fingerprint
[+] FUDAN based card
...
[=] --- PRNG Information
[+] Prng................. weak
[+] Static enc nonce..... yes
```

> 清單 1：hf mf info Proxmark3 指令的部分輸出

這些卡片在 [17] 上被稱為「0390」、「0490」、「FM11RF08 v3」等，並且已知來自上海復旦微電子。「0390」和「0490」指的是位於卡片區塊 0 中的製造商數據的第一個和最後一個位元組。提到了一個變體「1090」作為 7 位元組 UID 版本。我們沒有任何樣本，但 Anton Savelev 非常樂意為我們在幾個樣本上進行了一些測試，值得熱烈感謝。

上海復旦微電子是一家著名的中國半導體公司，以生產非接觸式智慧卡晶片而聞名，包括被視為 NXP MIFARE Classic 1K 晶片「相容替代品」的 FM11RF08。

復旦在該領域由來已久，2001 年的一項專利申請 [18] 似乎描述了 CRYPTO-1 協議，這比 2008 年被公開逆向工程 [6] 早了好幾年。不幸的是，我們沒有找到任何關於新卡片對策的專利。

到了 2023 年底，Augusto Zanellato 建議該卡可能是 FM11RF08S，但在當時，這個建議並沒有引起太多注意。

### B. 查看 FM11RF08S 數據表

FM11RF08S 數據表 [19] 確實提到了一項對策：晶片型號中添加的「S」代表「安全提升版本」，翻譯為「Security improved version」，安全功能列表中提到的一個功能可以翻譯為「與舊版晶片相比，抗破解能力有所提高」。

另一份標題完全相同的文件 [20] 描述了 FM11RF08S 的 7 位元組 UID 版本。

復旦網站的一個頁面 [21] 用英文提到了該對策：「與舊版晶片 RF08 相比，RF08S 的安全性和抗破解能力得到了增強，修復了算法實現中的弱點，同時不失功能相容性。」

這聽起來確實相當有希望。

### C. 獲取樣本……和一個 APK

由於我們目前無法識別我們的 2020 年樣本，最好的做法是訂購一些 FM11RF08S（在一個以「A」開頭的著名中國線上市場上）。我們想確定我們會得到 FM11RF08S 而不是舊的 FM11RF08，所以我們向供應商要求了一些保證。令我們驚訝的是，供應商提到了一個復旦 Android 應用程式（Play 商店上沒有），可以用來驗證標籤。搜尋該 APK，我們發現了一個「FM11RF08/08S 原廠認證」網頁 [22]，上面有一個 QR Code 可以下載它 [23]。安裝後，該應用程式的標題樸實地稱為「NFC Label Tools」。


安裝後，該應用程式將我們的 2020 年樣本識別為兩顆正版 FM11RF08S 晶片！調查可以在我們收到訂單之前開始。

圖 1：NFC Label Tools 識別 FM11RF08 卡片。

圖 2：NFC Label Tools 識別 FM11RF08S 卡片。

### D. FM11RF08S 簡易與進階驗證方法

讓我們稍微深入研究一下這個應用程式，因為它似乎具有有趣的正版卡片認證機制，類似於 NXP 所謂的原創性檢查（originality check）。一種稱為簡易驗證方法，另一種稱為進階驗證方法。

#### a) 簡易驗證方法：

位於區塊 0 的 FM11RF08 和 FM11RF08S 的 8 位元組製造商數據包含 6 個看似隨機的位元組，形成一種對（部分）其他區塊 0 位元組的加密簽名（可能是部分 HMAC？）。清單 2 給出了一個範例，取自我們訂購的新卡片。根據另外兩個製造商位元組，下一個卡片版本被非官方暱稱為「0490」。

```
1C 4C 75 63 46 08 04 00 04 75 DE 7A FD 3B 88 90
                        04 \__ signature __/ 90
\_________/ \/ \/ \___/
                        \_____________________/
    UID     BC SAK ATQA Manufacturer data
```

> 清單 2：FM11RF08S 區塊 0 範例

到目前為止，我們已經看到 FM11RF08S 樣本「0390」、「0490」和「1090」，以及 FM11RF08 樣本「011D」、「021D」和「031D」，這兩個型號都可以通過簡易驗證方法進行驗證。在本文 1.5 版發布後，Jackson Ouzts 報告了一個 FM11RF08S 樣本「0590」，也用這種方式驗證了。指紋識別指標已整合到附件 A.15 中。APK 似乎也顯示存在區塊 0 以「91」、「92」、「93」和「98」、「99」、「9A」結尾的 FM11RF08/08S 卡片。我們稍後將在第二十節和第十九節回顧其中一些。

那些製造商數據為 `6263646566676869` 且沒有簽名的舊復旦卡片，顯然無法被驗證。

如果卡片區塊 0 可以讀取，簡易驗證方法可以直接在前面提到的網頁 [22] 上線上完成，或透過 Android 應用程式完成。該應用程式使用的 API 與線上表單略有不同²，該方法可以重現，如清單 3 所示。

> ²自本文首次發表以來，APK 和 API URL 已更改，現在支援埠號 22443 上的 mTLS 連線，客戶端私鑰在最近版本的 APK 中稍微混淆了。然而，API 仍然可以使用常規 TLS 在埠號 443 上訪問。URL 已在此修訂版中相應調整。

```bash
wget -q --header="Content-Type: application/text; charset=utf-8" --post-data "1C4C7563460804000475DE7AFD3B8890" -O - https://nfc-tools.fmsh.com/nfcTools/api/M1KeyRest | json_pp
# {
#   "code": 0,
#   "data": null,
#   "message": "success"
# }
```

> 清單 3：簡易驗證方法 API

#### b) 進階驗證方法：

此方法僅受最新的 FM11RF08S 晶片支援，並且只能透過 Android 應用程式執行，無法透過線上表單。

用 Proxmark3 嗅探該應用程式顯示，它對未知的區塊 128（而 1k 卡只有 64 個區塊）與未知的 KeyA³ 執行 CRYPTO-1 認證。沒有執行讀取存取，僅認證成功這一事實就驗證了進階驗證方法。

> ³這提供了一種快速檢測 FM11RF08S 的方法：檢查它是否對指令 `6080` 回覆隨機數，但不對 `607F` 回覆。

即使卡片受到保護以抵禦針對卡片的攻擊，CRYPTO-1 如果在知道正確金鑰的讀卡機和卡片之間有追蹤紀錄，仍然很容易被破解，所以我們可以輕鬆恢復它。每張卡片的金鑰都不同，嗅探應用程式的網路操作揭示了另一個 API（如清單 4 所示），只要提交區塊 0，就可以簡單地返回特定卡片的區塊 128 KeyA。

```bash
wget -q --header="Content-Type: application/text; charset=utf-8" --post-data "1C4C7563460804000475DE7AFD3B8890" -O - https://nfc-tools.fmsh.com/nfcTools/api/getKeyA | json_pp
# {
#   "code": 0,
#   "data": "0543C7A1F992",
#   "message": "success"
# }
```

> 清單 4：進階驗證方法 API

令人驚訝的是，API 返回金鑰時並沒有驗證提交的區塊 0，如清單 5 所示。這允許進行一些測試，我們可以觀察到返回的 KeyA 僅取決於區塊 0 的前 9 個位元組。

```bash
wget -q --header="Content-Type: application/text; charset=utf-8" --post-data "00000000000000000000000000000000" -O - https://nfc-tools.fmsh.com/nfcTools/api/getKeyA | json_pp
# {
#   "code": 0,
#   "data": "EDCA04F1D3EC",
#   "message": "success"
# }
```

> 清單 5：使用無效數據的進階驗證方法 API

較新的「0590」樣本揭示了 API 使用方式的變化。最初，API 返回了錯誤的金鑰。檢查最新的 APK 顯示，對於第九個位元組 ≥ 0x05 的 4 位元組 UID 卡片，應用程式會製作一個偽區塊 0：將「05」和「90」位元組替換為「FF」和「FF」，並用隨機值填充它們之間的六個簽名位元組。使用該偽區塊 0，API 返回正確的金鑰（見清單 6）。因此，即使無法讀取實際的區塊 0，僅知道此類近期卡片的 4 位元組 UID 就足以構建一個區塊 0 並執行進階驗證方法。同樣的機制也適用於 7 位元組 UID 卡片，若其第九個位元組 ≥ 0x11。

```bash
wget -q --header="Content-Type: application/text; charset=utf-8" --post-data "C7F0DD04EE080400FF000000000000FF" -O - https://nfc-tools.fmsh.com/nfcTools/api/getKeyA | json_pp
# {
#   "code": 0,
#   "data": "9996473E4CF8",
#   "message": "success"
# }
```

> 清單 6：針對「0590」卡片的進階驗證方法 API

當然，這兩種驗證方法都只使用靜態數據，因此克隆仍然是可能的，類似於 NXP 的原創性檢查功能。但在工業規模上，克隆製造商無法在沒有大量獲取正版標籤並進行 1 對 1 克隆的情況下大量生產。此外，根據應用程式，復旦 API 可能會在某個時候返回錯誤代碼 -11 =「請求過多」。

我們測試這個新的認證金鑰，觀察到它可以對 2020 年的「0390」樣本的區塊 128 到 135 使用。它們共享相同的內容，顯示在清單 7 中。

```
128 | A5 5A 3C C3 3C F0 00 00 00 00 00 00 00 04 08 88
129 | 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
130 | 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
131 | 00 00 00 00 00 00 70 F7 88 0F 00 00 00 00 00 00
132 | 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
133 | 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
134 | 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
135 | 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
```
> 清單 7：較舊的 FM11RF08S 區塊 128 – 135

新獲得的「0390」和「0490」卡片（以及後來的「0590」樣本）和「1090」卡片與舊的「0390」表現不同。只有尾部區塊 131 和那個「可能是尾部區塊但是空的」區塊 135 可以被讀取，如清單 8 所示。

```
131 | 00 00 00 00 00 00 00 F0 FF 0F 00 00 00 00 00 00
135 | 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
```
> 清單 8：較新的 FM11RF08S 區塊 128 – 135（嘗試）

讓我們比較一下存取權限。表 I 解釋了 2020 年的「0390」樣本。

> 表 I：較舊的 FM11RF08S 區塊 128 存取權限 = 70F788

|     | 存取權限 |
| --- | ------------- |
| 128 | 讀取 AB；寫入 B |
| 129 | 讀取 AB；寫入 B |
| 130 | 讀取 AB；寫入 B |
| 131 | 讀取 AB |

而對於後來的「0390」、「0490」、「0590」和「1090」，我們得到表 II 中描述的存取權限。

> 表 II：較新的 FM11RF08S 區塊 128 存取權限 = 00F0FF

|     | 存取權限 |
| --- | ------------- |
| 128 | 無 |
| 129 | 無 |
| 130 | 無 |
| 131 | 讀取 AB |

我們將在第八節回到這些無法讀取的區塊……

我們沒有發現其他隱藏區塊。

### E. CRYPTO-1 實作特異性

FM11RF08S 具有以下實作特異性。有些已經在 IV.A 節中提到。

- 所有隨機數，初始和嵌套的，均由 16 位元 LFSR PRNG 生成；
- 無 NACK 漏洞；
- 初始 𝑛𝑇 不是靜態的，具有相當高的重複性；
- 加密嵌套 {𝑛𝑇} 是靜態的，且與第一個 𝑛𝑇 無關。

讓我們詳細說明最後兩點。

#### a) 初始 𝑛𝑇 特異性：

圖 3 顯示，在收集的 500 個隨機數中，它們都集中在 $2^{16} - 1$ 個可能的 16 位元 LFSR 輸出的極少數連續輸出上。這是舊卡片的典型特徵，如果偶然連續測試導致相同的 𝑛𝑇 值，Proxmark3 有時可能會錯誤地將其檢測為靜態隨機數。

![](https://i.imgur.com/lyX4Mep.jpeg)

> 圖 3：在 FM11RF08S 上進行 500 次認證嘗試觀察到的初始 𝑛𝑇

這是由於 LFSR 初始化為一個常數值，然後一旦卡片通電並運行，就會不斷計時。因此，初始 𝑛𝑇 值取決於自卡片通電以來認證請求的時間。

當在不中斷射頻場的情況下進行多次初始認證時，還必須考慮到 LFSR 在認證過程中本身是不計時的，因為卡片需要 LFSR 電路來計算 CRYPTO-1 協議所需的 suc64(𝑛𝑇 ) 和 suc96(𝑛𝑇 ) 函數（參見附件 A.1）。

### F. 嵌套 𝑛𝑇 特異性

[17] 上的社群討論報告稱，靜態加密隨機數在某種程度上取決於卡片 UID、磁區和使用者金鑰本身——但不取決於金鑰類型，因此如果對於給定磁區 KeyA == KeyB，加密隨機數也會相等。

因此，通過查看 KeyA {𝑛𝑇} 和 KeyB {𝑛𝑇}，我們可以判斷 KeyA 是否等於 KeyB。

澄清一下，當然，{𝑛𝑇} 取決於金鑰，但 𝑛𝑇 也是！

找到這張卡片攻擊方法的一個線索是了解 𝑛𝑇 究竟是如何生成的，並看看它是否在某種程度上可預測。

第十節將提供更多見解，但這不是我們最初遵循的線索。

為了我們的分析需求，我們在 Proxmark3 [13] 中實作了一個工具來測試各種嵌套認證場景，請參閱附件 A.3 以了解用法和範例。

## V. 重複使用金鑰嵌套攻擊

如果 𝑛𝑇 是靜態的，如何獲得更多隨機數？

我們說過 𝑛𝑇 取決於 UID 和磁區（以及金鑰）。如果我們假設一個金鑰在另一個標籤（另一個 UID）或同一標籤的另一個磁區上重複使用，我們將為同一個金鑰獲得另一個 𝑛𝑇 ！

攻擊條件：
- 知道第一個金鑰，以便能夠啟動嵌套認證協議；
- 卡片必須在幾個磁區中重複使用某些金鑰。或者基礎設施中的幾張卡片共享相同的金鑰。

這個攻擊有點類似於靜態嵌套攻擊，但我們不知道嵌套 𝑛𝑇 的明文，所以我們必須考慮所有 65535 個 𝑛𝑇∗ 候選者。

我們的策略將包括為一個參考磁區找到所有可能的金鑰候選者，並即時檢查它們是否與我們想要比較的任何其他磁區相容。這比一次尋找所有磁區的共同金鑰更受限，但它不需要任何大記憶體，而第二個選項需要約 3 Gb 乘以磁區數量。

1) 收集幾個磁區的 UID𝑖、嵌套加密隨機數 {𝑛𝑇}𝑖（可能跨越不同卡片）及其 4 位元加密同位 {𝑝𝑛𝑇}𝑖；

2) 對於每個目標磁區，生成所有 $2^{16} - 1$ 個可能的 16 位元 LFSR 輸出作為候選者 𝑛𝑇𝑖∗

3) 對於每個 𝑛𝑇𝑖∗，計算金鑰流 ks0𝑖∗ = {𝑛𝑇}𝑖 ⊕ 𝑛𝑇𝑖∗ ；

4) 給定 ks0𝑖∗，解密 {𝑝𝑛𝑇}𝑖 中的前 3 個同位位元

5) 檢查它們是否匹配 𝑛𝑇𝑖∗ 的前 3 個同位位元

6) 過濾後，剩下 $2^{(16-3)} = 8192$ 個候選者。將它們存儲為 (𝑛𝑇∗, ks0∗)𝑖 元組；

7) 將這些候選者分配到多個執行緒以進行後續步驟；

8) 在每個執行緒中，首先考慮 UID0、{𝑛𝑇}0 和 {𝑝𝑛𝑇}0 作為比較的參考磁區，以及它分到的 (𝑛𝑇∗, ks0∗)0 部分；

9) 對於每個 (𝑛𝑇∗, ks0∗)0，透過恢復並回滾 CRYPTO-1 48 位元 LFSR 無產生 $2^{16}$ 個可能的金鑰；

10) 針對其他磁區 {𝑛𝑇}𝑖 及其對應的 UID𝑖 測試這些金鑰：

a) 解密 {𝑛𝑇}𝑖 => 𝑛𝑇𝑖∗ ；
b) 檢查 𝑛𝑇𝑖∗ 是否為有效的 16 位元 LFSR 輸出；
c) 檢查 𝑛𝑇𝑖∗ 是否為該磁區 8192 個候選者的一部分；
d) 生成下一個金鑰流字 ks1𝑖∗ 以解密 {𝑝𝑛𝑇}𝑖 並檢查最後一個同位位元；
e) 對參考磁區做同樣的事：生成下一個金鑰流字 ks0𝑖∗ 以解密 {𝑝𝑛𝑇}0 並檢查最後一個同位位元。這原本可以早點做，但延後做會更有效率；

最後，對於每個磁區，我們得到數百個與參考磁區相容的金鑰候選者。

然後我們可以檢查除了參考磁區之外，是否至少有兩個不同的磁區存在共同金鑰。如果有的話，我們就找到了參考磁區和這些磁區的唯一金鑰。

在我們的筆記型電腦上，比較兩三個磁區不到 2 分鐘，比較 16 個磁區大約 12 分鐘。你的情況可能會有所不同，但這給出了一個大概的概念。注意，如果金鑰在磁區間重複使用，可能是在鄰近的磁區，所以可能不值得一次比較所有磁區。

我們在 Proxmark3 [13] 中實作了此攻擊，請參閱附件 A.5 以了解用法和範例。

如果沒有找到共同金鑰，也許參考磁區和單一磁區之間仍有共同金鑰。但這需要測試參考磁區卡片上的數百個金鑰。

此攻擊只能破解重複使用的金鑰，無論是跨磁區還是跨卡片。剩餘的金鑰仍然未被破解。

RFID 研究的時代精神顯而易見：就在本文初步提交給會議幾週後，Nathan Nye 在 RFID 駭客 Discord [17] 上分享了同樣的想法，即從跨磁區重複使用的金鑰收集多個 𝑛𝑇 ，並附上了概念驗證代碼。我們感謝並致敬 Nathan 的努力和對社群的貢獻。

## VI. 發現後門

由於對我們第一次攻擊的侷限性不太滿意，並且遵循我們已驗證的方法（參見 I.C 節），我們決定對指令集進行輕量級的模糊測試（fuzzing）。

這裡的所有數字均以十六進制表示。

原則上，通電時，卡片應該只對初始的 7 位元指令 REQA (26) 和 WUPA (52) 有反應。事實也是如此。然後只有防碰撞選擇 (93)。最後，在認證之前，應該只接受 KeyA 和 KeyB 的認證指令（60** 和 61**）以及 HLTA (5000)。我們嘗試所有參數位元組為「00」的指令值：**00，我們觀察到卡片回覆：

- 總是 NACK (4)，除了
- 5*00 → 卡片停止（halt）
- 6*00 → 卡片返回隨機數
- f*00 → 卡片停止

卡片可能將所有 5*00 作為 HLTA 反應。對於 f*00，效果看起來也類似於 HLTA。即使將 f*00 指令擴展到 40 個位元組也沒有任何結果。

有趣的是 6*00，這意味著我們對所有 6000 到 6f00 指令都會得到隨機數，而不僅僅是 6000 和 6100。

我們決定在一張已知金鑰的卡片上測試它們。我們設置不同的 KeyA 和 KeyB 並觀察靜態加密隨機數。當使用已知金鑰執行嵌套認證時，我們得到：

- 6000, 6200, 6800, 6a00 → {𝑛𝑇} = 4e506c9c, 成功
- 6100, 6300, 6900, 6b00 → {𝑛𝑇} = 7bfc7a5b, 成功
- 6400, 6600, 6c00, 6e00 → {𝑛𝑇} = 65aaa443, 失敗
- 6500, 6700, 6d00, 6f00 → {𝑛𝑇} = 55062952, 失敗

如果我們更改 KeyA，6000、6200、6800、6a00 的隨機數會變成另一個值，但 6400、6600、6c00、6e00 也會得到另一個隨機數。

不同的隨機數和認證失敗……看起來我們需要另一個金鑰……我們沒有展示出來，但當 KeyA == KeyB 時，我們只會為前兩組得到一個隨機數，為後兩組得到一個隨機數。這似乎表明神秘金鑰對於這兩組是相同的。

認證的不同指令位元組似乎被解析為位元欄位，如清單 9 所示。

```
7 6 5 4 3 2 1 0
        0 1 1 0
        | | | + 0=A 1=B
        | | + 忽略?
        | + 0=A/B 金鑰  1=後門金鑰
        + 忽略?
```
> 清單 9：認證指令 6x 被視為位元欄位

## VII. 破解 FM11RF08S 後門金鑰

讓我們更進一步，假設這個神秘金鑰對於多個，甚至所有磁區都是相同的。我們可以很容易地測試它，因為我們在第五節中有一個完全針對此假設的新攻擊。果然，兩分鐘後，一個金鑰出現了。詳情請參閱附件 A.5.3。快速測試立即顯示，該金鑰適用於卡片的所有磁區，無論 KeyA 和 KeyB 的值為何，而且也適用於我們可以測試的所有 FM11RF08S 樣本！FM11RF08S「0390」、「0490」、「0590」和 FM11RF08S-7B「1090」變體共享相同的後門金鑰。

讓我們深吸一口氣。

顯然，所有 FM11RF08S 都實作了一個後門認證指令，並且整個生產線使用唯一的金鑰。
而且我們破解了它。

```
A396EFA4E24F
```
> 清單 10：FM11RF08S 通用後門金鑰

測試顯示，一旦認證成功，即使尾部區塊存取權限顯示數據區塊不可讀，我們也可以讀取所有使用者區塊。我們也可以讀取尾部區塊，但 KeyA 和 KeyB 值被遮蔽（masked）。

注意，只需使用後門認證一次（在任何磁區上），就能夠讀取任何其他磁區的任何其他區塊，而無需重新認證，如附件 A.12.3 所示。

例如，現在我們可以像在清單 11 中那樣轉儲第四節 D.b 中提到的原本不可讀的區塊。

```
128 | A5 5A 3C C3 3C F0 00 00 00 00 00 00 00 04 08 88
129 | 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
130 | 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
131 | 00 00 00 00 00 00 00 F0 FF 0F 00 00 00 00 00 00
132 | 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
133 | 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
134 | 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
135 | 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
```
> 清單 11：較新的 FM11RF08S 區塊 128 – 135

除了我們已經知道的區塊 131 存取權限外，它們揭示了與 2020 年舊「0390」完全相同的內容。

FM11RF08S-7B 樣本在區塊 128 中有不同的內容，如清單 12 所示。

```
UID: 1D5FA23A000003
128 | A5 5A 3C C3 2D F0 00 00 00 00 03 37 71 04 08 88

UID: 1D7CDE72000003
128 | A5 5A 3C C3 2D F0 00 00 00 00 03 68 39 04 08 88
```
> 清單 12：FM11RF08S-7B 區塊 128 樣本

到目前為止，我們沒有找到使用後門金鑰寫入區塊的方法。

此外，我們也沒有發現同一組指令之間的差異。但這可能值得更深入的測試。

## VIII. 後門嵌套攻擊

經過更多測試後，我們意識到對於 60**，... 和 64**，... 認證指令組，明文 𝑛𝑇 實際上是相同的。先前顯示的 {𝑛𝑇} 是不同的，但實際上是同一個 𝑛𝑇 用兩個不同的金鑰加密的。同樣的情況也適用於 61**，... 和 65**，... 組。

所以，例如我們可以
1) 使用後門指令 6408 對區塊 08 發起認證；
2) 將 {𝑛𝑇}6408 解密為 𝑛𝑇6408 ≡ 𝑛𝑇6008 ；
3) 基於 ks0_6008 = 𝑛𝑇6008 ⊕ {𝑛𝑇}6008 攻擊其 KeyA。

此攻擊類似於第三節 D 中在第二次認證技巧之前描述的靜態嵌套攻擊，需要在卡片上測試數萬個金鑰候選者，破解一個金鑰可能需要 3-4 分鐘。

如同第五節的第一個攻擊，在恢復並回滾 48 位元 LFSR 後，我們可以解密同位位元並檢查最後一個同位位元，以將需要測試的金鑰候選者數量減少大約一半。這對於優化的靜態嵌套攻擊來說不太重要，但在這裡很有幫助。

我們在 Proxmark3 [13] 中實作了此攻擊，請參閱附件 A.6 以了解用法和範例。

我們現在可以用一種非優化的靜態嵌套攻擊破解任何 FM11RF08S 的所有金鑰，即使所有金鑰都經過多樣化（diversified），因為我們已經知道一個金鑰……而且我們不再需要重複使用金鑰的存在。

順帶一提，除了區塊 128 的進階驗證 KeyA，我們還可以破解其 KeyB，它也是多樣化的。

但奇怪的是，在我們所有的樣本上，它的前兩個位元組總是 0000。當破解這個特定金鑰時，我們可以根據此標準過濾金鑰候選者並瞬間破解金鑰。為什麼——以及這個金鑰可以用來做什麼——至今仍是一個謎。

有人也可以透過此攻擊恢復 KeyA，從而模擬包含 KeyA 的 FM11RF08S，而無需查詢 KeyA 的復旦 API。

對於 2020 年的卡片，根據表 I 中顯示的存取權限，似乎我們應該能夠在使用恢復的 KeyB 認證時寫入這些區塊。但測試顯示，雖然寫入指令似乎被卡片正確接受並確認，但實際上內容並沒有更新。

## IX. 另一種恢復嵌套隨機數的方法

在第八節中，我們看到了如何使用後門恢復明文嵌套 𝑛𝑇 值。但在 FM11RF08S 上，還有另一種方法，這是 Nathan Nye 在我們於 Discord [17] 伺服器上的早期對話中已經假設過的。不幸的是，當時由於共享實驗數據的一些混亂，我們錯誤地否定了它。在本文的 1.3 版修訂中，我們將重新討論它。

他的假設（現在已通過適當的測試驗證）是，失敗的嵌套認證隨機數與下一次初始認證隨機數之間的距離取決於這兩次認證之間的時間。在內部，這意味著用於生成嵌套隨機數的 16 位元 LFSR 只是在這些認證之間沒有重新初始化或隨機化。如果我們仔細控制時間，我們可以保持這個隨機數距離恆定。實際上，取決於卡片的位置：太近或太遠可能會發生一些抖動。一種策略是監控隨機數距離，同時將標籤物理移離讀卡機，直到隨機數距離變得最大且恆定。

恢復卡片金鑰的步驟如下。在第一階段，我們發現標籤的隨機數距離。

- 在其中一個磁區獲得第一個已知金鑰；
- 使用已知金鑰認證該磁區；
- 開始再次對同一磁區進行認證，但使用嵌套認證；
- 收集並使用已知金鑰解密 {𝑛𝑇𝑥} ；
- 發送一個位元組以中斷嵌套認證；
- 再次選擇卡片；
- 使用相同的金鑰認證同一磁區；
- 收集 𝑛𝑇𝑦 ；
- 計算距離 𝑑 = index(𝑛𝑇𝑦) − index(𝑛𝑇𝑥) ；

重複第一階段在不同的物理距離，直到隨機數距離穩定。

在第二階段，我們恢復未知金鑰的靜態加密隨機數的明文值。

- 使用已知金鑰認證同一磁區；
- 開始對具有未知金鑰的磁區進行認證；
- 收集 {𝑛𝑇𝑥′} ；
- 發送一個位元組以中斷嵌套認證；
- 再次選擇卡片；
- 使用已知金鑰認證已知磁區；
- 收集 𝑛𝑇𝑦′ ；
- 從 index(𝑛𝑇𝑥′) = index(𝑛𝑇𝑦′) − 𝑑 計算 𝑛𝑇𝑥′ ；
- 基於 ks0 = 𝑛𝑇𝑥′ ⊕ {𝑛𝑇𝑥′} 攻擊金鑰。

在此階段，我們處於與第八節非常相似的情況，並且可以應用相同的優化。

我們在 Proxmark3 [13] 中實作了明文隨機數恢復，請參閱附件 A.7 以了解用法和範例。

## X. 逆向嵌套隨機數生成

我們原本以為第二個攻擊已經結束了，但出於好奇，我們決定看看靜態加密隨機數 𝑛𝑇 生成本身，這在第四節 F 中有簡短提及。

首先，我們測試並確認了 𝑛𝑇 可能的依賴性和非依賴性。

𝑛𝑇 不依賴於

- 先前的嵌套認證次數（參見第三節 D 的靜態嵌套攻擊技巧）；
- 同一磁區內的區塊編號；
- 先前的認證 𝑛𝑅, 𝑛𝑇 , 磁區；
- 提交給卡片的金鑰；
- 當前認證之前的任何其他活動：對另一個磁區、使用另一個金鑰的嵌套認證、讀取……；
- 另一個磁區金鑰的值（例如，如果使用 KeyA 認證，則為 KeyB）；
- 存取權限；
- 金鑰類型：A vs. B。

但 𝑛𝑇 依賴於

- 當前認證配置的金鑰；
- 磁區編號（即使是相同的金鑰）；
- 卡片。

對卡片的依賴性可能是任何值，例如

- UID；
- 區塊 0 或 8 位元組製造商數據或 6 位元組「簽名」，參見第四節 D.a；
- 區塊 128 KeyA，參見第四節 D.b；
- 區塊 128 KeyB，參見第八節末尾；
- 任何其他可存取但尚未發現的個性化值；
- 卡片獨有且無法存取的隨機秘密種子（seed）。

在最後一種情況下，甚至可能是每個磁區一個隨機種子，這意味著我們找不到與磁區編號的關係。

為了分析對金鑰的依賴性，我們為 Proxmark3 編寫了一些 Python 腳本，以配置不同的金鑰（始終在同一個磁區上），然後收集並解密相應的 {𝑛𝑇}。該腳本實作了記憶化（memoization），以避免在嘗試不同的數據表示和分析時重複相同的查詢。

分析的一些決定性步驟重現於附件 A.14 節。結果是一個 Python 函數，如附件清單 27 所示，能夠將與第一個金鑰相關聯的隨機數變異為任何其他金鑰的隨機數。這種關係有點太複雜，無法用代數方式表達 Python 代碼，但它涉及兩種 4 位元 sbox 以交替模式使用，以便在不同時間對金鑰的每個半字節（nibble）應用差異到 LFSR 狀態。

有些人可能會找到一種更簡潔的方式來表達金鑰對生成的 𝑛𝑇 的影響。

我們也尋找與磁區編號的一些關係，但我們找不到任何模式，跨磁區的差異都是特定於每張卡片的。

## XI. 更快的後門嵌套攻擊

我們的 𝑛𝑇 生成分析結果有限，但它們已經可以為第八節中描述的後門嵌套攻擊提供這兩個優化。

- 我們可以針對給定磁區的 KeyA 和 KeyB，假設它們不同（可以透過比較 {𝑛𝑇𝐴} 和 {𝑛𝑇𝐵} 來檢查）；
- 我們使用帶有指令 64** 和 65** 的後門來解密它們的 𝑛𝑇𝐴 和 𝑛𝑇𝐵 ；
- 我們得到數萬個 KeyA 金鑰候選者，KeyB 也是如此；
- 我們搜尋滿足清單 27 中隨機數關係的 KeyA/KeyB 對。

為此，我們不是來回滾動 LFSR，而是實際上使用它們的金鑰候選者倒轉隨機數，並尋找 A 和 B 之間的共同祖先。

這種新的過濾允許將候選者數量減少到原始大小的大約 35%。這使得對卡片的線上暴力破解攻擊快了近 3 倍。

我們在 Proxmark3 [13] 中實作了此攻擊，請參閱附件 A.8 以了解用法和範例。

但是一旦我們找到了實際的 KeyA，假設我們無法使用 KeyA 直接讀取 KeyB（這取決於實際存取權限），我們可以直接透過再次使用該關係在金鑰候選者中找到正確的 KeyB。

我們在 Proxmark3 [13] 中實作了此攻擊，請參閱附件 A.9 以了解用法和範例。

所以我們的部分逆向工程使得攻擊速度潛在優化了 6 倍。

另一個直接的優化是首先生成所有金鑰候選者，過濾它們，然後查看出現在多個候選列表中的金鑰，並從測試這些入圍的候選者開始。

## XII. 完整卡片恢復

總結來說，破解 FM11RF08S 所有金鑰的策略如下。

步驟 1：線上收集隨機數

- 收集所有磁區所需的隨機數，KeyA 和 KeyB；
  - 在第一次認證中使用後門，然後進行嵌套認證以收集並解密它們的 𝑛𝑇𝐴 和 𝑛𝑇𝐵 ；
  - 在第一次認證中使用後門，然後在嵌套認證中使用目標金鑰類型，以收集 {𝑛𝑇𝐴} 和 {𝑛𝑇𝐵} 以及相應的同位錯誤；

步驟 2：離線計算

- 對於每個磁區
  - 如果 𝑛𝑇𝐴 ≠ 𝑛𝑇𝐵，對每個金鑰執行附件 A.6 中的 staticnested_1nt，然後對兩個候選列表執行附件 A.8 中的 staticnested_2x1nt_rf08s 以減少它們；
  - 否則對其中一個執行 staticnested_1nt ；
- 尋找跨磁區候選列表的共同金鑰。如果有，先測試它們；
- 當在磁區中找到金鑰且隨機數不同時，使用附件 A.9 中的 staticnested_2x1nt_rf08s_1key 查找另一個金鑰。
- 如果有預設金鑰字典可用，可以用於生成的候選列表以優先考慮已知金鑰。

步驟 3：線上暴力破解

- 對於每個金鑰槽，測試計算出的候選者。

我們在 Proxmark3 [13] 中實作了一個應用此策略的腳本，請參閱附件 A.10 以了解用法和範例。

總而言之，實際速度取決於卡片的確切配置，例如，如果 KeyA==KeyB 且未在其他磁區重複使用，破解磁區金鑰會比較慢——這是實際部署中很少見的極端情況。

為了說明恢復 FM11RF08S 所有金鑰所需的時間取決於卡片上某些金鑰的重複使用情況，我們在配置了以下佈局的卡片上進行了一些測試。

- 32 個隨機金鑰
  - 21 分 18 秒
- 16 個隨機金鑰，每個磁區 KeyA = KeyB
  - 32 分 29 秒（最壞的可能極端情況）
- 24 個隨機金鑰，8 個在 2 個磁區中重複使用
  - 16 秒（有利情況）

參見附件 A.10 以獲取有關測試金鑰的詳細資訊。

## XIII. 輕量快速供應鏈攻擊

顯然，任何知道後門的實體都可以在沒有卡片金鑰先決條件的情況下，對所有磁區金鑰進行針對卡片的攻擊，最多在半小時內完成。

但是，憑藉我們目前的部分知識，供應鏈中的任何人都已經可以使攻擊瞬間完成。

1) 在交付給目標客戶之前，使用預設的 FFFFFFFFFFFF 金鑰探測每張卡片，以收集並解密每個磁區的嵌套 {𝑛𝑇}。只需存儲每個 16 位元 LFSR 祖先和 UID，即每張卡片 36 個位元組；

2) 在現場，對於每個要破解的金鑰，使用後門金鑰進行認證，然後使用後門金鑰發起嵌套認證以收集 {𝑛𝑇} 並解密它；
3) 如第八節和第三節 D 所述，生成數萬個金鑰候選者；
4) 根據第 XI 節，透過將其 LFSR 祖先與步驟 1 中先前存儲的祖先進行比較來過濾候選者並恢復金鑰；

或者，可以使用第九節來恢復明文 𝑛𝑇 值。此攻擊不再需要對卡片進行任何金鑰候選者暴力破解，只需一次嵌套認證嘗試。由於此變體需要已知金鑰，因此在第一階段獲取區塊 128 KeyA 或存儲區塊 0 以便稍後請求金鑰可能會很有用。

我們在 Proxmark3 中添加了支援來演示這種供應鏈攻擊，如附件 A.10.5 所示。

當然，如果每個磁區的 𝑛𝑇 是透過基於磁區編號某種方式派生一個共同值生成的，那麼供應商就不需要收集所有磁區的 LFSR 祖先，只需收集一個。如果 𝑛𝑇 生成也可以鏈接到例如 UID，則可以完全跳過第一個收集步驟。

## XIV. 擴展驗證方法

第四節 C 中提到的 NFC Label Tools 應用程式只有在區塊 0 可以使用預設全 FF 金鑰讀取時才能應用原廠驗證方法（直到型號「0590」，其中可以從 UID 構建偽區塊 0 以透過 API 獲取有效金鑰。）

使用後門金鑰，我們可以執行進階驗證方法，無論卡片金鑰是否未知。

1) 使用後門讀取區塊 0，參見 A.12.2 節；
2) 將區塊 0 提交給簡單驗證方法 API，參見清單 3 並檢查答案；
3) 將區塊 0 提交給進階驗證方法 API 以獲取區塊 128 KeyA，參見清單 4；
4) 嘗試使用檢索到的 KeyA 認證區塊 128。

## XV. 觀察較舊的 FM11RF08

我們測試了後門認證指令，結果……我們也得到了一些 {𝑛𝑇}！但是 FM11RF08S 的後門金鑰在我們的 FM11RF08 樣本上不起作用。

## XVI. 破解較舊的後門金鑰

FM11RF08 容易受到第三節 B 中提到的經典嵌套攻擊的影響。因此，只需調整 Proxmark3 代碼以使用後門指令，就可以立即找到金鑰，如附件 A.12.4 所示。

```
A31667A8CEC1
```
> 清單 13：較舊的通用後門金鑰

同樣的金鑰適用於所有磁區以及我們獲得的所有 FM11RF08「011D」、「021D」和「031D」樣本。但不僅如此。

即使是非常舊的、製造商數據為 6263646566676869 的 FM11RF08 樣本也共享相同的後門和相同的金鑰。很難知道這些卡片從何時開始流通，但仍然可以找到 2008 年 5 月的 FM11RF08 數據表 [24]，並且復旦網站 2007 年 11 月的 WaybackMachine 快照中也提到了 FM11RF08 [25]。

> 請注意，一些其他克隆和魔術標籤（Magic Tags）也共享相同的製造商數據，但沒有後門。

同一頁面還提到了它們的 4k 版本 FM11RF32 [26]。我們剛好有一些製造商數據為 6263646566676869 的舊 FM11RF32 樣本，並且我們可以確認相同的後門金鑰也適用於這些 FM11RF32。它們具有 64 個磁區，而不是通常的 40 個磁區，並且可能是 FM11RF32M [27]變體的祖先。

> 這些樣本使用奇怪的 SAK=20 值，因為設置其第六位意味著卡片應該符合 ISO14443-4 並回覆 ATS。但此標誌必須被忽略，否則卡片在某些讀卡機（包括智慧型手機）上無法正常工作。

在我們分享初步結果後，Dušan Seničić 報告說 FM1208-10 和 FM1216-137 也支持舊的後門金鑰，Anton Savelev 為我們在 FM1208-10 上進行了一些測試，參見第二十一節。感謝他們！
FM1208-10 又名 FM1208M01 [28]，是一款具有 MIFARE Classic 相容性的 8051 CPU 卡（ISO14443A-4），而 FM1216-137 [29] 則是雙介面版本。後來，Maksim Negamashev 報告了具有相同後門金鑰的 FM11RF08-7B 版本的存在。

## XVII. 暗黑嵌套攻擊 (Darknested Attack)

這是一個非常直接的攻擊，可能不值得擁有自己的名字，但聽起來很酷。Darknested 利用第十六節揭示的這個相當黑暗的後門金鑰知識，作為在需要第一個已知金鑰時引導嵌套攻擊的一種簡單方法，而不是使用 Darkside 攻擊。正如第二節 C 末尾提到的，由於復旦卡總是洩漏 NACK，Darkside 攻擊無論如何都很快。但這種方法在某些情況下仍然很有趣，我們稍後會看到。有關範例，請參閱附件 A.12.6。

## XVIII. USCUID/GDM

被稱為 USCUID 或 GDM [30] 的魔術 MIFARE Classic 卡具有高度可配置性，不僅可以激活許多魔術功能（gen1a、cuid、shadow mode...），還可以啟用靜態加密隨機數模式。

靜態加密隨機數機制與 FM11RF08S 不同，需要更多研究，本文不涵蓋。

## XIX. 奇特的 FM11RF08S 0498 & 0598

在 1.1 版發布後，Luis Miranda Acebedo 向我們報告了一個具有 A31667A8CEC1 金鑰的標籤，但具有 FM11RF08S 的所有其他特徵：存在進階驗證方法磁區（ACL 00F0FF）、無 NAK 洩漏和靜態加密隨機數。區塊 0 為 313F961D85080400045073AF6EEB5998，並且其簽名已通過復旦 API 驗證。感謝他為我們進行這些測試！在第四節 D.a 中，我們提到 APK 確實可以潛在地識別區塊 0 以「98」結尾的卡片。為了驗證這一點，我們可以獲取相應的進階驗證方法金鑰並模擬兩種驗證方法使用的標籤元素。

```bash
hf mf esetblk --blk 0 -d 313f961d85080400045073af6eeb5998
hf mf esetblk --blk 3 -d ffffffffffffff078069ffffffffffff
hf mf esetblk --blk 143 -d f6e1399ee612ff078069ffffffffffff
hf mf sim --1k --allowkeyb --allowover
```

> 清單 14：用於通過復旦驗證方法的基本模擬 Proxmark3 指令

確實，復旦 Android 應用程式成功將模擬標籤識別為 FM11RF08S。

因此，該型號是真正的 FM11RF08S，但帶有 FM11RF08 後門金鑰。

後來，DXL 報告了一個具有相同特徵的真正 FM11RF08S 0598。

兩種指紋識別卡片指標均已整合到附件 A.15 中。

## XX. 一張奇特的 FM11RF08 0391

這張卡片就像是在本文 1.5 版中添加的，是前一張卡片的相反反映。當 Iceman 檢查他大量的卡片收藏時，他發現了一張似乎是 FM11RF08S 的卡片，具有預期的 A396EFA4E24F 後門金鑰和進階驗證方法區塊 128 到 135，但沒有靜態加密隨機數。因此，該卡容易受到經典 Darkside 和嵌套攻擊的影響，就像 FM11RF08 一樣。與清單 7 中顯示的區塊內容相比，這張卡的區塊 128 不同：區塊 128 的第五個位元組是 F0 而不是 3C。一個大膽的假設是，該位元組配置了靜態加密隨機數對抗措施的激活，並且在此樣本上未設置。

```
128 | A5 5A 3C C3 F0 F0 00 00 00 00 00 00 00 04 08 88
131 | 00 00 00 00 00 00 00 F0 FF 0F 00 00 00 00 00 00
```
> 清單 15：奇特的 FM11RF08 區塊 128 & 135

區塊 0 是 `395760060808040003C78B23D8BEA991`，並且其簽名已通過復旦 API 驗證。隨著在上一節 XIX 中遇到的「98」，「91」是第四節 D.a 中識別為潛在有效最後一個字節的另一個值，但在當時尚未與實際卡片相關聯。現在情況就是這樣。

由於存在額外區塊，我們可以嘗試在卡片的模擬上進行進階驗證方法。

```bash
hf mf esetblk --blk 0 -d 395760060808040003c78b23d8bea991
hf mf esetblk --blk 3 -d ffffffffffffff078069ffffffffffff
hf mf esetblk --blk 143 -d aa2547495940ff078069ffffffffffff
hf mf sim --1k --allowkeyb --allowover
```
> 清單 16：用於通過復旦驗證方法的基本模擬 Proxmark3 指令

復旦 Android 應用程式成功將模擬標籤識別為 FM11RF08。此樣本非常引人注目，它是真正的 FM11RF08，但具有 FM11RF08S 後門金鑰並支持進階驗證方法。
其指紋識別指標已整合到附件 A.15 中。

## XXI. 錦上添花 (Icing on the Cake)

在我們的卡片收藏中測試後門金鑰時，試圖找出復旦卡片，我們意識到一些非復旦卡片也接受範圍從 62** 到 6f** 的認證指令，但使用常規金鑰。

但是，非常令人驚訝的是，除了復旦卡片之外，還有一些其他卡片接受相同的後門認證指令，使用與 FM11RF08 相同的金鑰！

這可以用 Proxmark3 很簡單地驗證，現在我們已經添加了對後門認證指令的支援，如附件 A.12.5 所示。

在此階段，重要的是盡可能確定這些卡片的真實性，除了它們的區塊 0 可能顯示的內容之外。在附件 A.15 中，我們使用了一些行為指標來比較它們。

經過深入分析，我們可以安全地聲稱以下卡片包含帶有 A31667A8CEC1 金鑰的後門，包括第十六節中提到的復旦卡片。

- Fudan FM11RF08 “6263646566676869”
- Fudan FM11RF08 “011D”, “021D” and “031D”
- Fudan FM11RF08-7B “101D”
- Fudan FM11RF08S “0498”
- Fudan FM11RF32(M?) “6269”
- Fudan FM1208-10
- Fudan FM1216-110
- Fudan FM1216-137
- Infineon SLE66R35：可能至少在 1996-2013 期間生產；（我們不確定製造商數據解釋為生產日期的準確性。）
- NXP¹³ MF1ICS5003：至少在 1998 年至 2000 年期間生產；
- NXP¹³ MF1ICS5004：至少在 2001 年生產。

以下卡片支援相同的未記錄認證指令，但使用的是常規 KeyA/KeyB。而且一旦認證了一個磁區，就無法在不認證該磁區的情況下讀取另一個磁區的區塊。

- NXP MF1ICS5005：在 ICN8 晶圓廠生產（位於荷蘭奈梅亨的 NXP 晶圓廠），至少在 2001 年至 2010 年期間；
- NXP MF1ICS5006：在 Fishkill 晶圓廠生產（位於美國紐約 Fishkill 的 NXP 晶圓廠，2008 年待售，但最終於 2009 年關閉），至少在 2005 年至 2008 年期間；
- NXP MF1ICS5007：在 ASMC 晶圓廠生產（位於中國上海。最初於 1988 年與飛利浦半導體合資，隨後於 1995 年更名為 ASMC，並於 2004 年重組為外商投資股份有限公司，NXP 股份於 2017 年出售，最終於 2019 年合併入 GTA），至少在 2010 年期間；
- USCUID/GDM 魔術卡。

我們可以測試的後續 NXP MIFARE Classic EV1 樣本（MF1S20*V1, MF1S50*V1, MF1S70*V1）對未記錄的認證指令回覆 NACK。

此列表將由社群根據他們的發現進行更新。

在上述卡片中，SLE66R35、MF1ICS5003 和 MF1ICS5004 可以真正受益於第十七節中提出的 Darknested 攻擊，因為借助 Darkside 攻擊恢復第一個金鑰要慢得多。

## XXII. 破解更多後門金鑰

在本文初步發布後，我們在我們的一堆卡片中發現了一張奇怪的卡片。起初，它看起來像是雙介面卡，但實際上它是接觸面結合了真正的 J3D081 晶片，而非接觸面則是另一個 MIFARE Classic 4k 晶片。透過光線照射卡片確認了不同晶片的存在。

附件 A.15 中顯示的指標表明非接觸式晶片是 Fudan FM11RF32，但沒有第十六節中提到的舊樣本所使用的錯誤 SAK。轉換為 ASCII 的製造商數據顯示 FDS70V01，這可能翻譯為 Fudan S70 (=4k) v01。

該卡回覆後門指令，但預設金鑰不起作用。你知道該怎麼做：我們針對後門執行嵌套攻擊，如附件 A.12.4 所示，並迅速獲得相應的金鑰。

```
518B3354E760
```
> 清單 17：在 FM11RF32N 上看到的通用後門金鑰

後來，我們可以確認剛購買的 Fudan FM11RF32N 樣本上也存在相同的後門金鑰。

故事並沒有就此結束。在本文初步發布後，Nathan Nye 在 Flipper Zero 固件中實作了後門檢測，當懷疑卡片具有未知後門金鑰時觸發警報。幾個月後，它得到了回報：在 1.4 版發布後，Joel Majem 報告了一個帶有未知後門金鑰的露營手環。擁有 Proxmark3 的 Zeus Ricote 確認了標籤上後門的存在，可以破解金鑰，並幫助識別標籤指紋，這似乎也是一張 Fudan FM11RF32N，製造商數據中具有相同的 FDS70V01 字節。後來，發現了更多具有相同金鑰的樣本。從那時起，Proxmark3 的 hf mf info 指令中實作了類似的未知後門金鑰檢測，參見附件 A.12.9。

```
73B9836CF168
```
> 清單 18：在 FM11RF32N 上看到的又一個通用後門金鑰

## XXIII. 數據優先攻擊 (Data-First Attack)

到目前為止，針對卡片的攻擊總是遵循相同的方案。

1) 與目標卡片互動並破解其金鑰；
2) 借助恢復的金鑰轉儲卡片內容；
3) 向相應的目標讀卡機複製或模擬完整的卡片。

儘管如此，無論卡片是哪一代，從我們 1998 年的 MF1ICS5003 到 2024 年的 FM11RF08S 標籤，後門的基本使用都不允許轉儲使用者金鑰，而只能轉儲數據塊（和存取位元）。我們已經看到，要獲得僅限卡片的完整轉儲，我們必須開發新的攻擊，或者對於舊的攻擊，適應現有的攻擊。

對於特工的使用來說，後門對於獲取 FM11RF08S 的完整克隆來說效率很低，因為它可能需要接觸卡片幾分鐘。

實際上，如果目標例如是繞過門禁控制，那麼借助後門僅讀取卡片數據和隨機數可能就足夠了，而無需嘗試恢復金鑰。

情境如下。

步驟 1：

- 潛入反派在他的豪宅舉辦的豪華派對；
- 不經意地撞倒目標並與卡片保持接觸 2 秒鐘。微笑著道歉。

這 2 秒是執行第 XII 節步驟 1 所需的時間，以收集所有 𝑛𝑇𝐴, 𝑛𝑇𝐵, {𝑛𝑇𝐴}, {𝑛𝑇𝐵}，它們的加密同位位元，以及因為我們已經使用後門金鑰進行了認證，卡片的所有數據。步驟 1 的時間在附件 A.10 中記錄的三次測試中是一致的；

步驟 2：

- 假裝要去洗手間以到達他的辦公室；
- 向目標讀卡機出示被盜的 UID。認證嘗試將失敗；
- 根據兩次失敗的認證嘗試的痕跡，在不到一秒的時間內恢復相應的金鑰¹²；
- 再次與讀卡機互動，但這次以有效的 CRYPTO-1 會話回應讀卡機的認證指令。
- 當讀卡機在成功認證後想要讀取數據塊時，出示步驟 1 中讀取的數據；
- 如果讀卡機對其他磁區進行額外的嵌套認證，則出示相應的被盜 {𝑛𝑇} 及其加密同位位元，並收集讀卡機的回應 {𝑛𝑅}{𝑎𝑅}。我們知道明文 𝑛𝑇 ，所以我們可以計算 𝑎𝑅。這提供了兩個 32 位元的金鑰流部分，足以恢復金鑰。

> ¹²我們尚未介紹僅限讀卡機的攻擊，但在 [7] 中，作者解釋了這種攻擊是如何可能的，僅基於內在的 CRYPTO-1 漏洞。另請參閱 [13] 中的工具 mfkey32v2。

我們在 Proxmark3 [13] 中實作了對此類已知 𝑛𝑇 情況下的嵌套認證金鑰恢復的支援，參見附件 A.11 以了解用法和範例。在我們的測試中，金鑰恢復耗時不到 0.2 秒。

這是一種非常高效的「先卡片後讀卡機」攻擊，只有藉助 FM11RF08S 中後門的存在才成為可能。

我們還在 Proxmark3 模擬模式中實作了支援，以完全自動處理此類情況，參見附件 A.13 以了解用法和範例。

我們必須感謝社群 [17] 強調了此方案早期版本中的一些缺點，並提出了另一種數據優先攻擊有意義的情況，如下所述。

RFID 系統在卡片數據中編碼各種權限並不罕見，可能是加密的，但獨立於 RFID 層，即卡片 UID 和通常從 UID 和某些未知金鑰多樣化函數 (KDF) 派生的唯一金鑰。如果不肖人士已經合法存取了該系統的一張卡片並恢復了其金鑰，那麼只需借助後門從同一系統的另一張目標卡片讀取數據，然後將數據複製到自己的卡片上即可。在企業系統中，這可能是將一日訪客卡「升級」為正式員工卡，或者低權限員工卡突然擁有高安全區域卡片的數據。在旅館業，房卡可以變異為另一張房卡，或者管家或經理卡。這些場景使用合法卡片，比使用模擬器或魔術卡引起的懷疑更少，並且與目標卡片的互動只需 1-2 秒。

## XXIV. 結論

上海復旦微電子的 FM11RF08S 晶片被認為是 MIFARE Classic 最安全的實作，挫敗了所有已知的針對卡片的攻擊。然而，我們展示了各種攻擊，發現了硬體後門的存在並恢復了其金鑰，這使我們能夠發動新的攻擊來轉儲和克隆這些卡片，即使它們的所有金鑰都已正確多樣化。該產品以及自至少 2007 年以來的所有先前 FM11RF08 和 FM11RF32 卡片中存在後門，引發了幾個問題，特別是考慮到這些晶片參考不僅限於中國市場。例如，作者在美國、歐洲和印度的許多旅館都發現了這些卡片。此外，我們該如何看待舊的 NXP（前身為飛利浦半導體）和 Infineon 卡片與 FM11RF08 共享完全相同的後門金鑰這一事實？

消費者應迅速檢查其基礎設施並評估風險。許多人可能不知道他們從供應商那裡獲得的 MIFARE Classic 卡實際上是 Fudan FM11RF08、FM11RF32M、FM11RF32N 或 FM11RF08S。

儘管如此，重要的是要記住，MIFARE Classic 協議本質上已被破解，無論卡片為何。如果攻擊者可以存取相應的讀卡機，總是能夠恢復金鑰。市場上有許多更強大的替代品（但我們不能保證沒有硬體後門……）。

本文背景下開發的各種工具和攻擊現已合併到 Proxmark3 源代碼中，如附件所示。

附件 A.16 中列出了一些未來研究的問題。

順便說一下，本文副標題翻譯自 "Y’en a un peu plus, je vous l’mets quand même ?"，這是一個典型的法國行銷策略，你在肉舖秤上得到的比要求的要多一點點。

這就是全部了，各位。

## 參考文獻

[1] K. Nohl and H. Plötz, “Mifare, little security, despite obscurity,” Presentation on the 24th Congress of the Chaos Computer Club, Slides, 2007.

[2] G. de Koning Gans, J.-H. Hoepman, and F. D. Garcia, “A practical attack on the MIFARE Classic,” in Smart Card Research and Advanced Applications: 8th IFIP WG 8.8/11.2 International Conference, CARDIS 2008, London, UK, September 8-11, 2008. Proceedings 8, 2008, pp. 267–282.

[3] K. Nohl, “Cryptanalysis of crypto-1,” Computer Science Department University of Virginia, White Paper, 2008.

[4] B. J. Hoepman, G. de Koning Gans, R. Verdult, R. Muijrers, R. Kali, and V. Kali, “Security Flaw in MIFARE Classic.”

[5] N. T. Courtois, K. Nohl, and S. O'Neil, “Algebraic attacks on the crypto-1 stream cipher in mifare classic and oyster cards,” Cryptology ePrint Archive, 2008.

[6] K. Nohl, D. Evans, S. Starbug, and H. Plötz, “Reverse-Engineering a Cryptographic RFID Tag.,” in USENIX security symposium, 2008.

[7] F. D. Garcia et al., “Dismantling MIFARE classic,” in Computer Security-ESORICS 2008: 13th European Symposium on Research in Computer Security, Málaga, Spain, October 6-8, 2008. Proceedings 13, 2008, pp. 97–114.

[8] F. D. Garcia, P. Van Rossum, R. Verdult, and R. W. Schreur, “Wirelessly pickpocketing a Mifare Classic card,” in 2009 30th IEEE Symposium on Security and Privacy, 2009, pp. 3–15.

[9] N. T. Courtois, “The dark side of security by obscurity and cloning MiFare Classic rail and building passes anywhere, anytime,” Cryptology ePrint Archive, 2009.

[10] J. D. Golić, “Cryptanalytic attacks on MIFARE classic protocol,” in Topics in Cryptology–CT-RSA 2013: The Cryptographers’ Track at the RSA Conference 2013, San Francisco, CA, USA, February 25-March 1, 2013. Proceedings, 2013, pp. 239–258.

[11] C. Meijer and R. Verdult, “Ciphertext-only cryptanalysis on hardened Mifare classic cards,” in Proceedings of the 22nd ACM SIGSAC Con- ference on Computer and Communications Security, 2015, pp. 18–30.

[12] Wikimedia Foundation, “Crypto-1.” [Online]. Available: https://en.wikipedia.org/wiki/Crypto-1

[13] C. Herrmann, P. Teuwen, O. Moiseenko, M. Walker, and others, “Proxmark3 – Iceman repo.” [Online]. Available: https://github.com/RfidResearchGroup/proxmark3

[14] NXP B.V., “MF1 IC S50 Functional specification – rev 5.2.” [Online]. Available: https://cdn-shop.adafruit.com/datasheets/S50.pdf

[15] Iceman, “Proxmark3 – Add 'hf mf staticnonce' - a nested find all key solution command for tags that has a static nonce.” [Online]. Available: https://github.com/RfidResearchGroup/proxmark3/commit/b37a4c14eb497b431f7443b9f685d7f2e222bfa0

[16] DXL/@xianglin1998, “Proxmark3 – StaticNested fast decrypt.” [Online]. Available: https://github.com/RfidResearchGroup/proxmark3/commit/de0549a269c0dbe0cf59dc0e964af18ca5ca16e7

[17] “RFID Hacking by Iceman.” [Online]. Available: https://discord.com/invite/iceman

[18] 钱 晓 州 , “用 于 ic 卡 的 数 据 安 全 通 信 的 加 密 方 法 及 电 路 .” [Online]. Available: https://patentimages.storage.googleapis.com/29/bf/3f/6bbe253af076ca/CN1337803A.pdf

[19] Shanghai Fudan Microelectronics Group, “FM11RF08S 8K bits EEPROM 非接触式 电电加密卡芯片 – 版本 1.2.” [Online]. Available: https://www.fmsh.com/AjaxFile/DownLoadFile.aspx?FilePath=/UpLoadFile/20230104/FM11RF08S_sds_chs.pdf&fileExt=file

[20] Shanghai Fudan Microelectronics Group, “FM11RF08S 8K bits EEPROM 非接触式 电电加密卡芯片 – 版本 1.2.” [Online]. Available: https://www.fmsh.com/AjaxFile/DownLoadFile.aspx?FilePath=/UpLoadFile/20230104/FM11RF08S_7B_sds_chs.pdf&fileExt=file 

[21] Shanghai Fudan Microelectronics Group, “FM11RF08 IC Card Chip (Contactless Chip with 8K EEPROM).” [Online]. Available: https://www.fm-chips.com/fm11rf08-ic-card-chip-contactless-chip-with-8k-eeprom-15403621277007328.html

[22] Shanghai Fudan Microelectronics Group, “FM11RF08/08S 原厂认证系统 V1.32.” [Online]. Available: https://nfc-tools.fmsh.com/m1/

[23] Shanghai Fudan Microelectronics Group, “NFC Label Tools v1.3.1.” [Online]. Available: https://nfc-tools.fmsh.com/m1/static/apks/NFC_tag_asst.apk

[24] Shanghai Fudan Microelectronics Group, “FM11RF08 8KBits Contactless Card IC Functional Specification – May 2008 v2.1.” [Online]. Available: https://www.scribd.com/document/413627595/Fudan-FM11RF08

[25] Shanghai Fudan Microelectronics Group, “Contactless Memory Card Chips (2007 Wayback Machine snapshot).” [Online]. Available: https://web.archive.org/web/20071103175419/https://www.fmsh.com/english/product_chipcard.php?category=3

[26] Shanghai Fudan Microelectronics Group, “FM11RF32 32KBits Contactless IC Card Chip – May 2008 v2.1.” [Online]. Available: https://pvc-kartice.rs/wp-content/uploads/2023/07/FM11RF32.pdf

[27] Shanghai Fudan Microelectronics Group, “FM11RF32M 32KBits Contactless IC Card Chip - Sep. 2013 v3.1.” [Online]. Available: https://eng.fmsh.com/AjaxFile/DownLoadFile.aspx?FilePath=/UpLoadFile/20170727/FM11RF32M_ds_eng.pdf&fileExt=file

[28] Shanghai Fudan Microelectronics Group, “FM1208M01 Contactless CPU Card Datasheet – May 2008 v0.2.” [Online]. Available: https://www.zotei.com/files/FM1208M01.pdf

[29] Shanghai Fudan Microelectronics Group, “FM1216 Series CPU Card Chip Datasheet – Sep. 2013 v1.1.” [Online]. Available: https://eng.fmsh.com/AjaxFile/DownLoadFile.aspx?FilePath=/UpLoadFile/20140904/FM1216_ps_eng.pdf&fileExt=file

[30] M. Shevchuk, “Proxmark3 – Notes on Magic Cards.” [Online]. Available: https://github.com/RfidResearchGroup/proxmark3/blob/master/doc/magic_cards_notes.md#mifare-classic-uscuid

[31] Romuald Conty, Romain Tartière, Philippe Teuwen, “Platform independent Near Field Communication (NFC) library.” [Online]. Available:https://github.com/nfc-tools/libnfc

[32] Infineon, “NRG™ SLE 66R35R / NRG™ SLE 66R35I Extended datasheet Revision 3.0.” [Online]. Available: https://www.infineon.com/dgdl/Infineon-NRG-SLE66R35x-ExtendedDatasheet-DataSheet-v03_00-EN.pdf?fileId=8ac78c8c7d0d8da4017d29f12b88391d

[33] Shanghai Fudan Microelectronics Group, “FM11RF005M 512Bits EEPROM Contactless Smart Card IC Functional Specification – May 2008 v1.1.” [Online]. Available: https://eng.fmsh.com/AjaxFile/DownLoadFile.aspx?FilePath=/UpLoadFile/20140904/FM11RF005M_FS_ENG.pdf&fileExt=file

[34] Shanghai Fudan Microelectronics Group, “FM1208M04 非接触 CPU 卡芯片 电品说明书 – 2010.7 版本 1.0.” [Online]. Available: https://www.card1688.com/files/smart_card/FM1208M04.pdf

[35] Infineon, “SLE 44R35S / Mifare short product info 07.99.” [Online]. Available: https://orangetags.com/wp-content/downloads/datasheet/Infineon/spi_sle44r35s_0799.pdf

[36] Shanghai Belling, “BL75R06SM 8K-bit EEPROM Contactless smart card chip 8/16/2006.” [Online]. Available: https://www.yumpu.com/en/document/read/37197400/bl75r06sm-8k-bit-eeprom-contactless-smart-card-chip

[37] Integrated Silicon Solution, Inc., “IS23SC4439 User Manual – July 13, 2006 Ver. 1.1.” [Online]. Available: https://www.tansoc.com/uploads/soft/171115/1-1G115155551.pdf

[38] Ангстрем, “КБ5004ХК3 БЕСКОНТАКТНОЕ РАДИОЧАСТОТНОЕ КРИПТОЗАЩИЩЕННОЕ ЭППЗУ 8К БИТ – Апрель 2001.” [Online]. Available: http://www.radioman-portal.ru/sprav/pdf/angstrem/5004xk3.pdf

[39] Mikron JSC, “MIK1KMCM 8Kbit Read/Write RF Transponder IC – June 2013- revised April 2015.”

[40] Shanghai Quanray Electronics Co., Ltd., “HF RFID QR2217 CHIP Datasheet – 2008.8.6 V1.01.” [Online]. Available: https://www.yumpu.com/en/document/read/8034761/shanghai-quanray-electronics-co-ltd-proxmarkorg

[41] Shanghai Huahong Integrated Circuit Co., Ltd., “SHC1101 Short Form Specifications – Sep. 2003, Revision 1.0.”

[42] Shanghai Huahong Integrated Circuit Co., Ltd., “SHC1104 Short Form Specifications – Nov. 2003, Revision 1.0.” [Online]. Available: https://www.card1688.com/files/SHC1104_IC_datasheet.pdf

[43] Юникор микросистемы, “UNC20C01R 1Kbyte EEPROM Contactless Card IC – 2006?.”

## A. 附件

### A.16 開放問題

在我們面臨的所有新問題中，我們試圖回答盡可能多的問題，但仍有一些問題沒有答案。我們希望社群能在不久的將來幫助解決其中一些問題。

A.16.1 具有後門金鑰的卡片
- 是否還有未提到的其他卡片支援其中一個後門金鑰，或者還有另一個？
  - 期待 FM11RF005M[33]、FM11RF32M[27]、FM1208-09、FM1208M04[34]、FM12AG08M01、FM12AS04M01 以及其他製造商……Infineon SLE44R35S[35]、SLE66R35I/R/E7[32]、Shanghai Belling BL75R06SM[36]、ISSI IS23SC4439[37]、Ангстрем КБ5004ХК3[38]、Mikron MIK1KMCM[39]、Quanray QR2217[40]、Shanghai Huahong SHC1101[41]、SHC1104[42]、Юникор UNC20C01R[43]……

- 是否有可能在透過後門認證指令認證時寫入區塊？
- 是否有可能在透過後門認證指令認證時讀取金鑰？

A.16.2 FM11RF08S
- 靜態加密隨機數是如何從卡片和磁區編號派生的？
  - 這可能會加速金鑰恢復，甚至在沒有後門的情況下也能保證它。

- 關於其進階驗證和區塊 128-135：
  - KeyA 是如何派生的？
  - KeyB 是如何派生的？以 0000 開頭的那個。
  - KeyB 可以用來做什麼？
  - 這些區塊數據可以用來做什麼？
  - 是否有方法寫入這些區塊？

A.16.3 FM11RF08/FM11RF08S
- 區塊 0 中的簡單驗證方法簽名是如何產生和驗證的？

A.16.4 具有額外認證指令的卡片：
- 我們是否錯過了在使用常規金鑰執行所有後門指令的卡片中的後門？
- 在僅具有常規金鑰的卡片以及具有後門金鑰的卡片中，額外認證指令 62xx-6Fxx 在存取控制和功能方面有何差異？
  - 它們如何依賴於定義的存取控制？
  - 卡片變體有何不同？
  - 它們是否只是卡片狀態機中未指定情況的偽影，還是真的有一些尚未發現的功能？

我們在 A.15 節的表格中僅觸及了表面。

A.16.5 USCUID/GDM
- 靜態加密隨機數在 USCUID/GDM 卡片中如何表現？
  - 如果此類卡片禁用了其他魔術後門，這可能會實現正確的金鑰恢復。

### A.17 更新日誌

2024-08-11 版本 1.0
- 初始發布

2024-09-05 版本 1.1
新增：
- RF08S：使用預設金鑰字典優先考慮候選者
- 又一個後門金鑰 (FM11RF32N)
- 新的數據優先攻擊場景和相應工具
- 改進的腳本計時和更新的腳本輸出
- 表格
  - 新樣本參考
  - 基於 libnfc 的新 FDT 測量
  - 新 ACL 狀態

勘誤：
- 修復了附件中嵌套認證協議描述的錯誤，感謝 José Lopes Esteves！
- Hardnested：修復隨機數估計，感謝 Iceman！
- 次要：改寫、錯別字和參考

2024-11-08 版本 1.2
新增：
- 可以透過單次後門認證直接讀取所有磁區的所有區塊，在 hf mf ecfill 中支援
- FM11RF08S **98 帶有 FM11RF08 金鑰
- predict_nt.py 中的單行 prev_state/next_state
- 在 hf 14a raw 中支援 crypto1
- 在 fm11rf08s_recovery.py 中支援供應鏈攻擊
- 支援數據優先/僅限讀卡機攻擊，包括支援嵌套認證
- 表格：新樣本參考
勘誤：
- 修復表格中的 SLE66 ACL
- 澄清 FM11RF32M 與 FM11RF32N
- 調整開放問題中其他未測試克隆的列表
- 錯別字

2024-12-12 版本 1.3
新增：
- FM1216-137 中的後門
- 新增第九節：另一種恢復嵌套隨機數的方法
- 新附件 A.7 詳細介紹了 Proxmark3 中對第九節的支援
- 參考書目：更多數據表

2025-03-06 版本 1.4
新增：
- FM1216-110 中的後門
- FM11RF08-7B 中的後門
勘誤：
- 刪除版本 1.3 附件中引入的錯誤複製貼上內容

2025-07-25 版本 1.5
新增：
- 樣本「未知 4」現在確認為 Giantec GT23SC4439
- 新樣本 Giantec GT23SC4469
- 新版復旦 Android 應用程式
- 新復旦 API URL 和可選 mTLS
- 帶有另一個後門金鑰的新樣本 FM11RF32N
- 支援進階驗證方法的新樣本 FM11RF08 0391
- hf mf info 中對未知後門金鑰的新檢測
- hf mf sim 中的新選項 --allowover 以繞過最近的限制

2025-09-07 版本 1.6
新增：
- 新樣本 FM11RF08S 0590
- 新樣本 FM11RF08S 0598 帶有 FM11RF08 金鑰
- 帶有靜態 𝑛𝑇 的新樣本
- 無需知道區塊 0 即可驗證最近 FM11RF08S 樣本的新復旦 API
- 從最新復旦 Android 應用程式中提取的新區塊 0 最後一個字節值
雜項：
- 本文入選 Pwnie Awards 2025「史詩成就」類別的三個提名者之一

感謝提交我們的人！

- 更新聯絡資訊

Proxmark3 工具在這些版本中進行了大量更新，參考提交現在是：
- 71621470bd1ac5caae64f24d4413bc1bcc3e65ef
